> Problem: [808. 分汤](https://leetcode.cn/problems/soup-servings/description/)

[TOC]

# 思路

概率的乘法和加法问题：第一步有四种选择，每种的概率都是0.25，第二步也有四种选择，概率也都是0.25……如此不断进行，直到这两碗破汤同时被分完了，或者第一晚汤先被挥霍完了。所有的分汤法构成了一颗四叉树。

理解题意后，暴力的方法：用深度优先搜索遍历这颗四叉树。由于这棵树的深度和节点数量未知，暴搜的时间复杂度也非常大，不出意外地，暴搜超时了。🤣

暴力搜索的过程，会多次求解相同的子问题，这恰好符合动态规划的使用场景。

改成动划，优化了时间

设 dp(i,j) 表示汤 A 和汤 B 分别剩下 i 和 j 份时所求的概率值，即汤 A 先分配完的概率 + 汤 A 和汤 B 同时分配完的概率除以 2 。 状态转移方程为：
dp[i][j] = (dp[i-4]][j] + dp[i - 3][j - 1] + dp[i - 2][j - 2] + dp[i - 1][j - 3]) / 4.0

在 n 非常大的时候，汤 A 会有很大的概率比 B 先分配完，汤 A 被先取完的概率应该非常接近 1。事实上，当我们进行实际计算时发现，当 n≥4475 时，所求概率已经大于 0.99999 了（可以通过上面的动态规划方法求出），它和 1 的误差（无论是绝对误差还是相对误差）都小于 10 ^ 5
因此在 n≥179×25 时，我们只需要输出 1 作为答案即可。在其它的情况下，我们使用动态规划计算出答案。

# Code

* []

```C

#define MAX(a, b) ((a) > (b) ? (a) : (b))

double soupServings(int n) {
     n = n = ceil((double) n / 25);
    if (n >= 179) {
        return 1.0;
    }
    double dp[n + 1][n + 1];
    dp[0][0] = 0.5;
    for (int i = 1; i <= n; i++) {
        dp[0][i] = 1.0;
        dp[i][0] = 0.0;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[MAX(0, i - 4)][j] + dp[MAX(0, i - 3)][MAX(0, j - 1)] + dp[MAX(0, i - 2)][MAX(0, j - 2)] + dp[MAX(0, i - 1)][MAX(0, j - 3)]) / 4.0;
        }
    }
    return dp[n][n];
}

```

